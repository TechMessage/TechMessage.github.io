<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="typescript">




  <meta name="keywords" content="ts,">





  <link rel="alternate" href="/default" title="null">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="https://techmessage.github.io/2019/07/24/typescript/">


<meta name="description" content="typsescript学习笔记官网文档 typecript是js的超集，不是新的语言，需要编译为js文件才可以在浏览器或者Node端执行  5分钟快速上手 安装   npm  install -g typescript   代码 1234567// hello.tsfunction greeter() &amp;#123;    console.log(&amp;apos;hello, world&amp;apos;)&amp;">
<meta name="keywords" content="ts">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript">
<meta property="og:url" content="https://techmessage.github.io/2019/07/24/typescript/index.html">
<meta property="og:site_name">
<meta property="og:description" content="typsescript学习笔记官网文档 typecript是js的超集，不是新的语言，需要编译为js文件才可以在浏览器或者Node端执行  5分钟快速上手 安装   npm  install -g typescript   代码 1234567// hello.tsfunction greeter() &amp;#123;    console.log(&amp;apos;hello, world&amp;apos;)&amp;">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://techmessage.github.io/images/Snipaste_2019-07-29_14-05-25.png">
<meta property="og:updated_time" content="2019-07-30T04:46:31.389Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="typescript">
<meta name="twitter:description" content="typsescript学习笔记官网文档 typecript是js的超集，不是新的语言，需要编译为js文件才可以在浏览器或者Node端执行  5分钟快速上手 安装   npm  install -g typescript   代码 1234567// hello.tsfunction greeter() &amp;#123;    console.log(&amp;apos;hello, world&amp;apos;)&amp;">
<meta name="twitter:image" content="https://techmessage.github.io/images/Snipaste_2019-07-29_14-05-25.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> typescript -  </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo"></a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          typescript
        
      </h1>

      <time class="post-time">
          Jul 24 2019
      </time>
    </header>



    
            <div class="post-content">
            <h1 id="typsescript学习笔记"><a href="#typsescript学习笔记" class="headerlink" title="typsescript学习笔记"></a>typsescript学习笔记</h1><h3 id="官网文档"><a href="#官网文档" class="headerlink" title="官网文档"></a><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">官网文档</a></h3><blockquote>
<p>typecript是js的超集，不是新的语言，需要编译为js文件才可以在浏览器或者Node端执行</p>
</blockquote>
<h2 id="5分钟快速上手"><a href="#5分钟快速上手" class="headerlink" title="5分钟快速上手"></a>5分钟快速上手</h2><ol>
<li><p>安装</p>
<blockquote>
<p> npm  install -g typescript</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// hello.ts</span><br><span class="line">function greeter() &#123;</span><br><span class="line">    console.log(&apos;hello, world&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeter()</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<blockquote>
<p>tsc hello.ts  ==&gt; 生成 hello.js</p>
</blockquote>
</li>
</ol>
<h2 id="handbook"><a href="#handbook" class="headerlink" title="handbook"></a>handbook</h2><blockquote>
<p>基本操作手册</p>
</blockquote>
<h3 id="Basic-Types-基本类型"><a href="#Basic-Types-基本类型" class="headerlink" title="Basic Types 基本类型"></a>Basic Types 基本类型</h3><blockquote>
<p>typescript支持所有js中数据类型，</p>
</blockquote>
<ol>
<li><p>boolean 类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isDone:boolen = false;</span><br></pre></td></tr></table></figure>
</li>
<li><p>number </p>
<blockquote>
<p> 在js中所有的数字类型都是浮点数，统一为number类型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a:number = 10</span><br><span class="line">let b:number = 0xfa11 //16进制</span><br><span class="line">let c:number = 0b1010 //2进制</span><br><span class="line">let d:number = 0o744 //8进制</span><br></pre></td></tr></table></figure>
</li>
<li><p>string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s:string = &apos;hello world&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>array</p>
<blockquote>
<p>ts中的数组，限定了数组元素的类型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list:number[] = [1,2,3]; //限定了数字类型数据，数组内元素只能为数字</span><br><span class="line">let list:Array&lt;number&gt; = [1,2,3]; //限定了数字类型数据，数组内元素只能为数字</span><br></pre></td></tr></table></figure>
</li>
<li><p>tuple 元组类型</p>
<blockquote>
<p>限定长度和每个索引位置元素的类型的数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let x:[string, number] = [&apos;1&apos;, 2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>enum 枚举类型</p>
<blockquote>
<p>ts中的枚举类型类似map，定义一组一一对应key-value对应关系，包装起来</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum Code &#123;</span><br><span class="line">    SUCCESS = 1002,</span><br><span class="line">    ERROR = 1003,</span><br><span class="line">    EXCEPTION = 1004</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c: Code;</span><br><span class="line"></span><br><span class="line">switch (c) &#123;</span><br><span class="line">    case Code.SUCCESS:</span><br><span class="line">        </span><br><span class="line">        break;</span><br><span class="line">    case Code.ERROR:</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    case Code.EXCEPTION:</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>any 任意类型，动态类型</p>
<blockquote>
<p>ts在个js中添加了变量类型检查的同时，也提供了一个any的类型，这个类型就和js中的变量是相似的，动态类型；相当于以一方面给js提供个变量的静态类型特性，另一方变也保留了js的动态特性。</p>
</blockquote>
</li>
<li><p>void 空类型</p>
<blockquote>
<p>void 类型用来表达函数没有返回值的情况</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>null , undefind 类型</li>
</ol>
<blockquote>
<p>null类型 只有一个值null; undefined类型也只有一个值undefined。这两个类型单独作用不大，这两个类型默认是其它类型的子类型，意味着其它类型可以赋值null或undefined。</p>
</blockquote>
<ol start="10">
<li>never 类型</li>
</ol>
<blockquote>
<p>这个类型用来 表示当某个函数中直接抛出异常时，返回值类型，或者一个函数陷入无限循环中，不会终止</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Function returning never must have unreachable end point</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Inferred return type is never</span><br><span class="line">function fail() &#123;</span><br><span class="line">    return error(&quot;Something failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Function returning never must have unreachable end point</span><br><span class="line">function infiniteLoop(): never &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>object 类型</li>
</ol>
<blockquote>
<p>object 类型不是原始数据类型</p>
</blockquote>
<ol start="12">
<li>type assertions 类型断言（类型转换)</li>
</ol>
<blockquote>
<p>你可以对确定的类型进行类型转换，有两种语法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1 </span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br><span class="line">// 2 </span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>

<h3 id="Variable-Declaration-变量声明"><a href="#Variable-Declaration-变量声明" class="headerlink" title="Variable Declaration 变量声明"></a>Variable Declaration 变量声明</h3><blockquote>
<p>let 和 const在es6中引入的关键字用来声明变量和常量,后者声明变量只能赋值一次，不能二次赋值。在es6之前只有var关键字是用来声明变量的，var声明变量有一些不好的特性，会给代码编写造成误导，特别是变量提升的特性。</p>
</blockquote>
<ul>
<li>var 声明变量</li>
</ul>
<blockquote>
<p>首先明确的是变量作用域仅仅和变量的声明有关，于函数的执行上下文无关;只有全局和函数才能形成作用域，变量的访问是从当前函数中以此往上层函数递归直至到全局的顺序。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 12</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">    var message = &quot;Hello, world!&quot;;</span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局声明的a变量，它的作用域就是全局的，在任何地方都可以访问；函数f中声明的变量message，它的作用域仅仅在函数中，换句话中在函数f中才可以使用变量message。</p>
</blockquote>
<ul>
<li>闭包<blockquote>
<p>闭包简而言之就是夸作用域访问变量的能力</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">    var a = 10;</span><br><span class="line">    return function g() &#123;</span><br><span class="line">        var b = a + 1;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f();</span><br><span class="line">g(); // returns &apos;11&apos;</span><br><span class="line">g = null; //释放闭包内存</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>分析上面代码: 函数f中声明了变量a和函数g, g函数中访问到a变量，并且g函数作为f函数返回值；在全局执行f()调用，将返回值赋值给全局的g变量，全局的g变量就可以访问到函数g中的a变量。其实从变量作用域的角度来看，a变量的是函数f中声明的，它的访问应该仅仅局限在函数f中，但是通过将f中的g返回出去，其中g中访问了a，那么相当于将a给暴露出去了。这就形成了闭包的过程。a变量的内存始终没有释放掉，因为它需要被全局的g访问到，那么可以全局的g执行完后，手动赋值null，那么就可以释放了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(`$&#123;i&#125;次循环`, i)</span><br><span class="line">    &#125;, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 上面的for循环代码块等价于</span><br><span class="line"></span><br><span class="line">var i;</span><br><span class="line">for(i = 0; i&lt;10;i++)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// var 声明变量都是有变量提升的，而且没有块的概念，存在于函数中或全局中</span><br><span class="line">// setTimeout是异步执行的，所以只有在for循环都执行完了，才会执行setTimeout中的函数，此时i=10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码在执行时输出都是10，因为var 声明的变量是函数的，不是在for循环的这个代码块中的</p>
</blockquote>
<blockquote>
<p>因为var 声明变量带来的诸多问题，所以在es6中引入了新的关键字let const 来声明变量</p>
</blockquote>
<ol>
<li>let 声明变量是块级别的，block scope ,哪些是代码块呢？for循环，if-else, try..catch 简言之就是带有{ }的</li>
<li>也没有变量提升的特性,意味着不能先使用后声明，这里的先后是代码的顺序</li>
<li>不能重复声明相同的变量，在一个代码块中</li>
</ol>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><blockquote>
<p>typescript相较于js最明显的就是变量的类型检查机制，那么interface就是ts中用来解决变量的类型定义的，准确来说是对象类型的数据的类型声明的</p>
</blockquote>
<ol>
<li>声明某个对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface People &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>声明一个People类型的对象，包含两个必要的属性name,age而且只能包含这两个属性</p>
</blockquote>
<ol start="2">
<li><p>如果对象中的某个属性可有可无，那么对应的属性后跟?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface People &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">    job?:string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果对象中某个属性值是readonly的，不能改写，那么在属性前带上readonly</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface People &#123;</span><br><span class="line">    readonly sex: string,</span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">    job?: string,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>interface 来定义函数接口,只需要函数的签名（参数列表及参数类型和返回值类型）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface getFullname &#123;</span><br><span class="line">    (first: string, last: string): string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>interface可以描述 索引类型的对象，意思是一个数组的访问方式，通过索引来访问值，但是需要规定索引的类型和值得类型;如果索引类型是number，那么意味着可以用数组或者对象来赋值给这个interface的变量，如果索引类型是string，那么只能是数组类赋值。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">interface my &#123;</span><br><span class="line">    [index: number]: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let l: my = &#123;</span><br><span class="line">    1: &apos;1&apos;,</span><br><span class="line">    2: &apos;2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let m: my = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface you &#123;</span><br><span class="line">    [index: string]: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let y: you = &#123;</span><br><span class="line">    1: &apos;1&apos;,</span><br><span class="line">    2: &apos;1&apos;,</span><br><span class="line">    3: &apos;1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>interface 描述类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date = new Date();</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><blockquote>
<p>js是基于原型继承，这一点没有变，class的写法只是一种语法糖</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string  // 成员属性</span><br><span class="line">    constructor(name: string) &#123;  //构造函数</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;   //原型方法</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>class的继承通过extends 显示声明，并且需要在子类的构造器中首先执行super()来执行父类的构造器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    name: string</span><br><span class="line">    age: number</span><br><span class="line">    constructor(name: string, age: number) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    grade: string</span><br><span class="line">    constructor(name: string, age: number, grade: string) &#123;</span><br><span class="line">        super(name, age)</span><br><span class="line">        this.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问修饰符，public protected private ，在java中，访问修饰符是控制一个类中的变量的可访问范围的限制，这种特性在js中并没有语言层面的规定。ts对此进行了特性的补充。class中的声明的变量默认是public的，protected声明的变量只能在本类以及子类中访问，private声明的变量只能在本类中使用。</p>
</blockquote>
<p><img src="/images/Snipaste_2019-07-29_14-05-25.png" alt="protected"></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/ts/">ts</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2019/07/04/CORS的简介/">
        <span class="next-text nav-default">CORS的简介</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">TechMessage.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
